trigger:
- '*'

variables:
  buildConfiguration: 'Release'
  releaseBranchName: 'release'

schedules:
- cron: '0 3 * * *'
  displayName: 'Deploy every day at 3 A.M.'
  branches:
    include:
    - release
  always: false

stages:
- stage: 'Build'
  displayName: 'Build the web application'
  jobs: 
  - job: 'Build'
    displayName: 'Build job'
    pool: EMRSTGSERVER

    variables:
      wwwrootDir: 'Tailspin.SpaceGame.Web/wwwroot'
      dotnetSdkVersion: '8.0.x'
      http_proxy: http://eproxy-emaar.goskope.com:8081
      https_proxy: http://eproxy-emaar.goskope.com:8081
      NODE_TLS_REJECT_UNAUTHORIZED: "0"

    steps:
    - powershell: |
        [Environment]::SetEnvironmentVariable("HTTP_PROXY", "http://eproxy-emaar.goskope.com:8081", "Process")
        [Environment]::SetEnvironmentVariable("HTTPS_PROXY", "http://eproxy-emaar.goskope.com:8081", "Process")
        [Environment]::SetEnvironmentVariable("http_proxy", "http://eproxy-emaar.goskope.com:8081", "Process")
        [Environment]::SetEnvironmentVariable("https_proxy", "http://eproxy-emaar.goskope.com:8081", "Process")
        [Environment]::SetEnvironmentVariable("NODE_TLS_REJECT_UNAUTHORIZED", "0", "Process")
      displayName: "Set proxy environment variables via powershell"
    
    - task: UseDotNet@2
      displayName: 'Use .NET SDK $(dotnetSdkVersion)'
      inputs:
        version: '$(dotnetSdkVersion)'

    - task: Npm@1
      displayName: 'Run npm install'
      inputs:
        verbose: false

    - script: './node_modules/.bin/sass $(wwwrootDir):$(wwwrootDir)'
      displayName: 'Compile Sass assets'

    - task: gulp@1
      displayName: 'Run gulp tasks'

    - script: 'echo "$(Build.DefinitionName), $(Build.BuildId), $(Build.BuildNumber)" > buildinfo.txt'
      displayName: 'Write build info'
      workingDirectory: $(wwwrootDir)

    - task: DotNetCoreCLI@2
      displayName: 'Restore project dependencies'
      inputs:
        command: 'restore'
        projects: '**/*.csproj'

    - task: DotNetCoreCLI@2
      displayName: 'Build the project - $(buildConfiguration)'
      inputs:
        command: 'build'
        arguments: '--no-restore --configuration $(buildConfiguration)'
        projects: '**/*.csproj'

    - task: DotNetCoreCLI@2
      displayName: 'Publish the project - $(buildConfiguration)'
      inputs:
        command: 'publish'
        projects: '**/*.csproj'
        publishWebProjects: false

        # $(Build.ArtifactStagingDirectory) is a built-in Azure DevOps variable — it’s a temporary folder on the build agent used to stage files before publishing them as artifacts.
        # So, if $(buildConfiguration) is Release, this becomes something like: --output C:\agent\_work\1\a\Release
        # The --output ... part simply says: “Put the published app files (and ZIP if enabled) into a temporary folder on the agent so I can publish them later as an artifact.”

        arguments: '--no-build --configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/$(buildConfiguration)' 

        # If zipAfterPublish: true is set, it will also generate: C:\agent\_work\1\a\Release\<yourproject>.zip
        zipAfterPublish: true

      # This .zip is then published as a build artifact in the next step, like this: This you can find in DevOps->pipeline->artifacts
      # The reason why push files to artifact to keep files secure because Microsoft-hosted agents are destroyed after each job. ven self-hosted agents can clean up work directories based on retention settings. If you don’t publish the file, it is gone after the build finishes.
    - publish: '$(Build.ArtifactStagingDirectory)'
      artifact: drop

- stage: 'Dev'
  displayName: 'Deploy to the dev environment'
  dependsOn: Build #Yes, it really checks that Build stage is completed and this stage will run only if Build completed successfully.
  condition: |
    and
    (
      succeeded(),
      eq(variables['Build.SourceBranchName'], variables['releaseBranchName'])
    )
  jobs:
  - deployment: Deploy
    pool: EMRSTGSERVER
    environment: dev
    variables:
    - group: Release # it refers variables group name that created in Azure DevOps. You can check under Pipelines -> Library
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: drop
          - task: AzureWebApp@1
            displayName: 'Azure App Service Deploy: website'
            inputs:
              azureSubscription: 'Resource Manager - Tailspin - Space Game'
              appName: '$(WebAppNameDev)'
              # $(Pipeline.Workspace)/drop/$(buildConfiguration)/*.zip points to the location on the build agent where the pipeline artifacts (ZIP files) are downloaded.
              # When the pipeline moves to the next stage, these artifacts are automatically downloaded from the artifact storage to the agent. [C:\agent\_work\1\b -> $(Pipeline.Workspace)]
              # The pipeline then uses these locally [ownloaded ZIP file -> $(Pipeline.Workspace)]package) for deployment tasks like publishing to a web app.
              package: '$(Pipeline.Workspace)/drop/$(buildConfiguration)/*.zip'

              # You cannot run any tasks in pipelines without agent support. Azure DevOps runs all pipeline tasks (build, test, deploy) on agents, whether they are: Microsoft-hosted or Self-hosted (your own machine/VM).
              # So, the agent needs the files locally to run the deployment command — like using az webapp deploy, FTP, or REST API behind the scenes.

- stage: 'Test'
  displayName: 'Deploy to the test environment'
  dependsOn: Dev
  #condition: eq(variables['Build.Reason'], 'Schedule')
  jobs:
  - deployment: Deploy
    pool: EMRSTGSERVER
    environment: test
    variables:
    - group: 'Release'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: drop
          - task: AzureWebApp@1
            displayName: 'Azure App Service Deploy: website'
            inputs:
              azureSubscription: 'Resource Manager - Tailspin - Space Game'
              appName: '$(WebAppNameTest)'
              package: '$(Pipeline.Workspace)/drop/$(buildConfiguration)/*.zip'